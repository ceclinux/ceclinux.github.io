古人云

> All problems in computer science can be solved by another level of indirection

所以从某种角度上，文件系统也就是给底层硬盘之类的IO设备加了一层抽象（indirection）。来一段维基

> 计算机的文件系统是一种存储和组织计算机数据的方法，它使得对其访问和查找变得容易，文件系统使用文件和**树形目录**的抽象逻辑概念代替了硬盘和光盘等物理设备使用数据块的概念，用户使用文件系统来保存数据不必关心数据实际保存在硬盘（或者光盘）的地址为多少的数据块上，只需要记住这个文件的所属目录和文件名。在写入新数据之前，用户不必关心硬盘上的那个块地址没有被使用，硬盘上的存储空间管理（分配和释放）功能由文件系统自动完成，用户只需要记住数据被写入到了哪个文件中。

用操作系统久了之后，很多人逐渐发现，基于树状的文件系统抽象似乎不是那么直观。比如我在写faq相关的时候，大多数在脑子第一想到的是我要编辑controller的名字`faqs_controller.rb`，然后想到到他的路径`uniqueway/cure/app/controllers/admin/faqs_controller.rb`。我们大脑里面关心的是文件的名字和用途，而往往不在乎他的路径

所以如何替代掉树状，增加我们访问文件的效率呢？我们不可能发明一个轮子，做一个不基于树形目录的文件系统（树状目录也绝非一无是处）。怎么办？常见有两个思路

## Cache

再来搬一段维基（顺便复习下基本概念 = =）

> 高速缓存文件置换机制

> 高速缓存文件置换机制是电脑处理缓存内存的一种机制。
> 电脑内存空间的大小固定，无法容纳服务器上所有的文件，所以当有新的文件要被置换入缓存时，必须根据一定的原则来取代掉适当的文件。此原则即所谓高速缓存文件置换机制。
> 缓存文件置换方法有：
>
> 先进先出算法（FIFO）：最先进入的内容作为替换对象
> 最近最少使用算法（LFU）：最近最少使用的内容作为替换对象
> 最久未使用算法（LRU）：最久没有访问的内容作为替换对象
> 非最近使用算法（NMRU）：在最近没有使用的内容中随机选择一个作为替换对象
> Belady's Min

正常我们再访问文件的时候，都是在文件系统这个树状的数据结构下进行自顶向下访问的。Cache的思想就是我们建立一个缓存区，来储存我们（经常访问 || 很可能下次访问 || 访问最多次 || ...)的文件和路径。 这样我们下次访问文件的时候， 不用再在树上的节点上慢慢爬拉，先看看缓存区在不在就好了。

这种思想已经有各种各样的实现，各类编辑器菜单里面都有（最近访问的文件），shell中你可以用[z](https://github.com/rupa/z)来根据频次跳转。当然**宇宙第一编辑器Vim**肯定也有的实现，神马你不知道，赶紧打开Vim，输入`h :mru`和`h :oldfiles`并朗诵一遍。

## 匹配检索

有人发现，树状目录下我们当前只能访问查看一个节点，如果错了还要退回来。试想如果能事先看到所有的节点，然后就不是可以直接找到文件了？当然可以！`ls -R`(-R ecursively list subdirectories encountered.)。文件太多，一个个看不过来怎么办？我们可以做一些匹配检索，过滤筛选掉一些。比如可以根据（文件名，文件内容，文件目录……）的特征运用一些匹配算法（史密斯-沃特曼算法 || 内德曼-文施算法 || ... ），然后直接从筛选的文件队列中找就行了。

这样做的好处相比于Cache方法，那些很少访问的文件也会很容易找到。所以对于最近编辑的文件，使用Cache类型工具会很方便，对于所有文件，使用匹配检索更好。当然结合起来用起来就更爽拉。大家很熟悉的`Ctrl-p`就是这样一个工具，那命令行有没有这样一个东西呢？当然就，就是**FZF**（终于拉回正题～）

## FZF

一图胜千言

![](https://raw.githubusercontent.com/junegunn/i/master/fzf-preview.png)

他的好处可多了，结合**宇宙第一编辑器Vim**可以这样

`vim -p $(fzf -m) //p: open N tab pages in vim, m: fzf multiple select `

可以多选文件，并把他们每个都新开一个`tab`

说好的结合使用Cache和匹配检索呢？和[z](https://github.com/rupa/z)结合一下就好了

```
unalias z
z() {
  if [[ -z "$*" ]]; then
    cd "$(_z -l 2>&1 | fzf +s --tac | sed 's/^[0-9,.]* *//')"
  else
    _last_z_args="$@"
    _z "$@"
  fi
}

zz() {
  cd "$(_z -l 2>&1 | sed 's/^[0-9,.]* *//' | fzf -q "$_last_z_args")"
}
```

命令好的好处就是能把各种小工具连在一起，[这里](https://github.com/junegunn/fzf/wiki/examples#integration-with-z)介绍了很多玩法，觉得好的扔进你的`.zshrc`吧
